`interval_aver`是用于对输入的`numpy.ndarray`进行区间平均的类。

#### 输入值
* `data`: 为需要进行区间平均的数据,为`numpy.ndarray`类型
* `ref`: 以第一行(`ref="row"`)还是第一列(`ref="col"`)作为进行区间划分的数据,默认为以第一列作为进行区间划分的数据
  ``` python
  a = np.array([
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]
  ])
  # 若ref=row,则将对[1, 2, 3, 4]进行区间划分
  # 若ref=col,则将对[1, 5, 9, 13]进行区间划分
  ```
* `bin`: 为需要划分的区间个数,默认为`10`
* `data_min`: 为区间最左端对应的数值,默认为进行区间划分的数据的最小值
* `data_max`: 为区间最右端对应的数值,默认为进行区间划分的数据的最大值

<strong>注意: 除`data`外,其余的输入值都为关键词参数</strong>

#### 输出值
若`i`为`interval_aver`的一个实例,那么:
* `i.num`: 在每一个小区间中数据出现的次数
* `i.avg`: 在每一个小区间中数据的平均值
* `i.max`: 在每一个小区间中数据的最大值
* `i.min`: 在每一个小区间中数据的最小值

#### 例子
* 例子1
  ```python
  a = np.array([
    [0.2, 0.8, 1.6, 5.4, 0.9, 1.0, 1.2, 5.9, 6.0],
    [1, 1, 1, 1, 1, 1, 1, 1, 1]
  ])
  example1 = interval_aver(a, ref="row", bin=5)    # 实例化interval_aver对象
  print(example1.num)
  # 输出值为:
  # [[0.2  1.65 3.1  4.55 6.  ]    
  #  [6.   0.   0.   2.   1.  ]] 
  print(example1.avg)
  # 输出值为:
  # [[0.2  1.65 3.1  4.55 6.  ]    
  # [1.    nan  nan 1.   1.  ]]  
  print(example1.max)
  # 输出值为:
  # [[0.2  1.65 3.1  4.55 6.  ]    
  # [1.    nan  nan 1.   1.  ]]  
  print(example1.min)
  # 输出值为:
  # [[0.2  1.65 3.1  4.55 6.  ]    
  # [1.    nan  nan 1.   1.  ]]   
  ```
  - 以第一行为进行区间平均的数据,由于这里没有指定`data_min`与`data_max`,因此`data_min=min(a[0,:])`,而`data_max=max(a[0,:])`,即`data_min=0.2`, `data_max=6.0`.在此大区间上，被划分为5个小区间,即每一个区间步长为1.45, 对应的每一个区间为`[0.2, 1.65)`, `[1.65, 3.1)`, `[3.1, 4.55)`, `[4.55, 6)`, `[6, 7.45)`.
  - 对于第二行在每一个小区间中数据出现的次数分别为6(对应0.2, 0.8, 1.6, 0.9, 1.0, 1.2), 0, 0, 2(对应5.4, 5.9), 1(对应6.0)故`print(example1.num)`的输出值为:
    ``` python
    [[0.2  1.65 3.1  4.55 6.  ]   #  -> 这一行为划分的小区间范围
    [6.   0.   0.   2.   1.  ]]   #  -> 这一行为在每一个小区间中数据出现的次数
    ```
  - 由于第二行在每一个小区间中数据的平均值分别为1, nan(表示该区间上为空值), nan, 1和1.故`print(example1.avg)`的输出值为:
    ```python
    [[0.2  1.65 3.1  4.55 6.  ]   #  -> 这一行为划分的小区间范围
    [1.    nan  nan 1.   1.  ]]   #  -> 这一行为在每一个小区间中数据的平均值
    ```
  - 对于第二行数据,由于其在每一个小区间中的数据最大值分别为1(对于区间`[0.2, 1.65)`,在该区间上的值有0.2对应的1, 0.8对应的1, 1.6对应的1, 0.9对应的1, 1.0对应的1, 1.2对应的1,故最大值为1), nan, nan, 1和1.故`print(example1.max)`的输出值为:
    ```python
    [[0.2  1.65 3.1  4.55 6.  ]   #  -> 这一行为划分的小区间范围
    [1.    nan  nan 1.   1.  ]]   #  -> 这一行为在每一个小区间中数据的最大值
    ```
  - 对于`example1.min`,其与`example1.max`,不同的是这里计算的是每一个区间中能够取到的最小值.

* 例子2
  ```python
  b = np.array([
    [1, 5, 9, 10],
    [1, 7, 9, 11],
    [4, 6, 6, 0],
    [7, 5, 9, 15],
    [10, 7, 3, 20]
  ])
  example2 = interval_aver(b, bin=3)     # 实例化interval_aver对象
  print(example2.num)
  # 输出值为:
  # [[ 1.   3.   3.   3. ]
  # [ 5.5  1.   1.   1. ]
  # [10.   1.   1.   1. ]]
  print(example2.avg)
  # 输出值为:
  # [[ 1.   6.   8.   7. ]
  # [ 5.5  5.   9.  15. ]
  # [10.   7.   3.  20. ]]
  print(example1.max)
  # 输出值为:
  # [[ 1.   7.   9.  11. ]
  # [ 5.5  5.   9.  15. ]
  # [10.   7.   3.  20. ]]
  print(example1.min)
  # 输出值为:
  # [[ 1.   5.   6.   0. ]
  # [ 5.5  5.   9.  15. ]
  # [10.   7.   3.  20. ]]
  ```
  - 以第一列为进行区间平均的数据,由于这里没有指定`data_min`与`data_max`,因此`data_min=min(b[:,0])`,而`data_max=max(b[:,0])`,即`data_min=1`, `data_max=10`. 在此大区间上，被划分为3个小区间,即每一个区间步长为4.5, 对应的每一个区间为`[1, 5.5)`, `[5.5, 10)`, `[10, 14.5)`.
  - 在`example2.num`的输出结果中,第一列为划分的小区间范围, 即对应着`[1, 5.5)`, `[5.5, 10)`, `[10, 14.5)`这3个区间.第二列为原始数据第二列在不同小区间上的平均值, 即对于第二列的数据在`[1, 5.5)`区间的平均值是6((5+7+6)/3=6),在`[5.5,10)`区间的平均值是5(5/1=5),余下的几列同上.
  - 在`example2.avg`的输出结果中,第一列为划分的小区间范围, 即对应着`[1, 5.5)`, `[5.5, 10)`, `[10, 14.5)`这3个区间.第二列为原始数据第二列在不同小区间上的平均值, 即对于第二列的数据在`[1, 5.5)`区间的平均值是6((5+7+6)/3=6),在`[5.5,10)`区间的平均值是5(5/1=5),在`[10, 14.5)`区间的平均值是7(7/1=7).其余的几列同上.
  - 在`example2.max`的输出结果中,第一列为划分的小区间范围, 即对应着`[1, 5.5)`, `[5.5, 10)`, `[10, 14.5)`这3个区间.第二列为原始数据第二列在不同小区间上的最大值, 即对于第二列的数据在`[1, 5.5)`区间的最大值是7,在`[5.5,10)`区间的最大值是5,在`[10,14.5)`区间的最大值是7.其余的几列同上.
  - `example2.min`的输出结果与`example2.max`类似,只是此时求的是每个区间上的最小值.

